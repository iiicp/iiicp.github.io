---
layout: post
title: c++中的多线程编程
tags: c++/thread
excerpt: about multi thread
---  

### pthread和std::thread的使用 
1. 线程创建 
2. 线程处理函数
3. 线程退出 

以上三点请参考我的[多线程测试](https://github.com/iiicp/project-arrange/tree/master/multi-thread-test)，我分别用两个类来进行测试. 

现在推荐使用std::thread，因为语言兼容了跨平台, pthread虽然也是跨平台但是
在windows上需要自己编译pthread线程库，比较麻烦。


### 关于等待线程退出 
	
线程是否退出是至关重要的，因为关联到资源是否被释放，在c++中是使用join的方式来等待线程退出。

std::thread提供了joinable和join，在join之前我们一般先调用joinable来进行检测，避免重复join.


线程退出不了的问题    

如果一个线程退出不了，那么代码就会阻塞在join函数调用处。导致应用卡死。当出现线程退出不了的时候，多半是
与死锁有关，导致控制线程退出的变量，得不到更新。所以线程和锁是两个相依相伴的角色，互相成就。因为线程并发需要访问共享资源，
因此要保护共享资源的安全性，才有了锁的用武之地，而因为锁，才能够使多线程成为可行的方式。


### 线程局部变量 

线程局部变量就是给每个线程单独携带些信息，通过这个可以定制化线程信息。std::thread提供了thread_local变量机制，
每个线程都会得到这个拷贝信息。使用时，threadlocal必须声明为类外全局变量，事例可以参考[线程局部变量测试](https://github.com/iiicp/project-arrange/tree/master/multi-thread-test)。
演示了创建5个线程，每个线程单独持有自己的file变量，自己根据自己的线程id来创建文件。
（相当于给系统的thread类加上了个局部属性，还是很有用的）

### 关于锁
1. 互斥锁
	std::mutex，需引入<mutex> c++11提供
2. 读写锁 
	std::shared_mutex，需引入<shared_mutex> c++17提供
	当写时，读写阻塞，当只有读时，是可以共享锁。适用于读的场景更多。
3. 可重入锁 
	就是递归锁，可以避免因重复加锁导致死锁的问题，对于重复加锁的问题，可以通过拆解子函数，然后提供wrapper来避免。 
4. C++封装的RAII类 
	std::lock_guard
	std::unique_guard，可以配合condition_var来使用 

具体使用的例子，可以参考我的[多线程锁的测试](https://github.com/iiicp/project-arrange/tree/master/multi-thread-test).


### 关于死锁 

某对象一直拿不到锁，就会死锁.
原因：
1. 之前错过了释放锁的时机，再次进入就会死锁。（比如因为异常提前退出，没走到解锁的代码）
2. 两个对象互相占有一个互斥资源，去请求对方的资源。(资源需要按序分配)
3. 对于互斥锁防止递归调用，设计时子函数若需要调用其它子函数，应该将此子函数拆分成多个子函数，设计一个包装的API，
让用户去调用。或者考虑可重入锁。推荐是拆分，一般而言底层库可以做成粒度很小的子函数，在此基础上，设计一些包装的API，
就不需要加锁了。


### 线程同步(协作)的方式 

**条件变量**   

条件变量机制有两点问题需要注意，分别是**信号量丢失**和**虚假唤醒**.

信号量丢失的问题 
	当被通知对象不是处于wait状态时，条件变量的notify是会被浪费掉的，所以如果要通过notify来做一些操作，被通知对象要放在循环中去处理，下一次循环时就能判断到上一次的状态修改了。

虚假唤醒问题 
	1. 系统系统有时候会唤醒条件变量，我们需要再次检测是否条件是否满足
	2. 即使一个线程让条件变量的条件满足了，到另外等待线程执行之前，中间又导致条件不满足了也是有可能，所以还需要判断下条件是否真的满足。
	所以解决这个问题的办法就是每次条件变量别激活时，再次检测条件的真实性。所以使用while()+wait的方式来做

补充一点   
为什么条件变量需要配合mutex来用，是因为解锁和休眠等待需要保持原子操作。若不是原子操作，在解锁后，时间片被切换到另外一个线程，再次发送条件信号，让条件满足了，等时间片再次切换到当前线程的休眠等待操作时，信号已经被浪费掉了，此时仍然会阻塞。

``` 
mutex.lock()
while (condition_var is not true)
{
	mutex.unlock();
	/// 此处解锁和休眠是分离的，可能unlock之后，被切换到其它线程，在回来的时候条件满足了
	/// 但是此时只能继续等待了
	/// 所以 解锁和等待 必须是原子的!!!
	sleep(); /// 等待
	mutex.lock();
} 
``` 

**信号量** 

std::thread并没有封装信号量，所以只能使用操作系统api来做. mac系统对于semaphore.h中sem_init和sem_destroy都设置为过期了.
所以推荐还是条件变量加锁的方式来进行同步。


**消息队列**

消息队列是对条件变量以及下面的生产者和消费者模型的一个封装. 实际中常会用消息队列在多个线程之间做数据共享。


### 生产者消费者模型 

```   
					 ---------
		   			| 输入队列 |
		   			 ---------

---------------------- 	     -------------------------
| 	 生产者线程				 | 消费者线程
|							 |
|							 |
| 1. 获取输入数据到输入队列		 | void processLoop()
|（若输入队列已满，此处会阻塞)	 | {
|							 | 1. 从消息队列取数据
|							 |	  (消息队列无数据，此处会阻塞)
| 2. 从输出队列获取处理完的		 | 2. 处理数据
| ----------------------	 | 3. 将处理完数据写到输出队列
							 |	  (输出队列已满，此处会阻塞)
							 |}
							 | -------------------------	

					 ---------
		   			| 输出队列 |
		   			 ---------

```

### 项目实践
1. 循环队列(消息队列)
	结合条件变量来实现生产者和消费者 

2. SDK库中网络请求的正确用法(封闭性)  
	设置一个单独的网络请求线程，既保证了多线程下网络请求发起安全，同时也能方便的控制网络请求退出 

### 多线程程序的debug 
1. log大法   
	对每一个不太频繁的方法都要打个info信息  
	对每一个可能异常退出的地方都要打上log

2. IDE辅助(xcode)    
	查看所有的线程
	查看堆栈