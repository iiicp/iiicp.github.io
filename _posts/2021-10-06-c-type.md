---
layout: post
title: c的type
tags: c语言
excerpt: 深入学习C
---


c语言的类型不是很丰富，这也大概是c语言学起来比较简单的原因吧。

总体而言类型分为简单类型和复合类型。

| 简单类型                     | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| _Bool                        | c99增加的bool类型，值只能为0或者1，非0值为1                  |
| char/unsigned                | 位宽为8bit，unsigned表示最高bit不是符号位. -128~127, (0~255) |
| short/unsigned               | 位宽16bit. (-2^15~2^15-1) (0~2^16-1)                         |
| int/unsigned int             | 位宽32bit                                                    |
| long/unsigned long           | sizeof(long) = 8 byte                                        |
| long long/unsigned long long | sizeof(long long) = 8 byte                                   |
| float                        | 一般是4个字节                                                |
| double                       | 一般是8个字节                                                |
| long double                  | sizeof(long double) = 16 byte                                |
|                              |                                                              |

| 复合类型 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| point    | 需要配合一个point to类型; point to int; point to point; point to void |
| array    | 需要配合array of 类型; array of int; array of array of int; array of point to int |
| func     | 决定是类型是返回类型(c++中不一样)；return of int; return of point to int |
| struct   | 用户自定义类型; 可以聚合基本类型和复合类型                   |
| union    | 用户自定义类型；取所有类型中的最大size的类型来分配内存       |
| enum     | 用户自定义类型；默认枚举值类型为int                          |
|          |                                                              |

c的作用域

struct/union/enum的tag属于一个作用域

全局变量/局部变量/typedef定义变量/struct/union成员变量属于一个作用域，内层作用域可以隐藏外层作用域，具备block作用域.

lable属于单独作用域，属于block内.

所有的enum成员属于一个作用域



c的类型完整性

所谓类型完整性是指能否求出类型的大小.

几处类型不完整的例子。

| incomplete        | 说明                                     |
| ----------------- | ---------------------------------------- |
| void/void *       | 因为没有指定具体的类型，无法求出类型大小 |
| int arr[] = {1,2} | 不完整类型，没有给出数组元素的数量       |
| void func();      | 没有函数定义，无法确定函数类型大小       |
|                   |                                          |

c的函数proto

由于历史语义原因，c的函数讨论有proto的概念。

如果c语言函数没有声明，即c语言函数是没有proto的。这会影响c语言函数传参的语义。由于没有proto，编译器会对函数实参数做默认参数提升。小于int的类型->int类型，float类型->double类型，这样会对函数栈参数传递，产生意想不到的问题，主要原因还是由于type的size截取导致。



c的类型的compatial

两个类型相容是指其限定符和基本类型相同。

比如const int a; const int b; 这两个类型是相容的。

struct A 和 struct B类型是不一样，同一个struct A a, struct A b，a和b类型相容。

如果类型不相容，在parse的时候会产生一个cast节点。



c的函数参数传递和赋值

函数参数传递隐含了类型的转换，比如小于int的类型->int类型，数组转换成point *，

函数转换成point * func。函数参数传递的过程中，会丢失掉类型限定符。



c语言还存在varidic类型

varidic也会影响到类型相容性的比较.