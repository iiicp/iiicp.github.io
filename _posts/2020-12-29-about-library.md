---
layout: post
title: 关于静态库动态库以及符号相关知识
tags: program
excerpt: library 
---  

### 前言

因为现在都用c/c++来开发，几乎无法避免的要接触各种编译和链接，每天都要和静态库、动态库和可执行程序打交道。
现在基本上只有三大编译器llvm/clang、gcc和vc，我们写些简单的程序还会用命令去写。比如如下的一些简单命令:

####关于静态库

``` 
# 静态库
clang++ -c add.cpp -o add.o
# r表示添加或替换指定文件到a中, v显示信息
ar -rv libadd.a add.o
# t表示按照顺序显示libadd.a中的.o文件
ar -t libadd.a
# d表示删除libadd.a中的某个.o文件
ar -d libadd.a add.o
# 链接成可执行成文件，需要使用L选项，指定静态库的路径
clang++ main.cpp -L . -ladd -o main
``` 

静态库优点是很直接很简单，依次将每个.c*源文件，执行编译.c* -> *.o，然后将所有的.o执行归档成*.a，最后
将*.a + main.o -> main.exe 链接成可执行文件。由这个过程可知
编译静态库不会执行链接过程，编译过程中只要符合c/cpp语法有前向声明就可以编译成功。所以千万不要认为静态库
编译成功了，你的库就没问题了。实际中经常会遇到，将静态库一进行链接就会出现各种链接错误，比如找不到定义，
这个时候就要看看这个函数实现是否编译到静态库里面去了。另外可能还有符号重定义问题，出现这个问题，表明
用户程序和你的静态库程序有相同的函数实现。一般来说我们用了比较出名的第三方库，我们都要hidden下这些符号，
优秀的第三方库，都会提供hidden的定义，或者通过宏定义来进行改名。


####关于动态库

```
# 动态库
clang++ -shared -fPIC add.cpp -o add.so
# 查看文件格式
file add.so
# linux platform
clang++ main.cpp -L. -ladd -o main
# mac platform
clang++ main.cpp add.so -o main
```
动态库的编译也比较简单，第一步也是分别将*.c -> *.o, (这一步是词法、语法、语义检测，通常是没问题)，第二步是将
所有的*.o->*.so/*.dylib/*.dll等，这一步和静态库的ar有明显差别，因为这一步存在链接的过程，对于所有调用的符号，
都会去找对应的实现代码，抽取到动态库中，也包含外部静态库的调用。所以在生成动态库的过程中，常常会在这一步，出现符号
调用问题，这一步解决之后，用户调用部分，就不会出现符号找不到了。
同时通过上面的命令，也能够体会到，不同平台具体的装载指令是有差别的，对于开发跨平台代码的开发人员来说，是增加了些
维护成本的，对于iOS和windows和Mac具有比较强大的IDE，通过IDE不用去写这些装载指令，只需要配置下头文件、库文件等路径
但是对于Android和Linux来说都是第三方来开发的，比如Android Studio和clion，
他们为了追求更多的通用性，不会给用户自动装载命令，需要手写CMakeLists.txt，
对于c/cpp程序员来说，CMake几乎成了通用的构建工具了，因此我们要熟悉CMake的构建指令，其实按照头文件和库文件已经生成
的target来写也是相对简单，我之前有介绍一个事例是编译aec模块。
补充一点对于windows平台的MT和MD的差别，MT和MD都是动态库生成，区别是MT会链接vc运行时库msvcrt.lib，通常是采用MD.

####动态库和静态库的优缺点

静态库缺点
1. 使用静态库集成相对来说要复杂点，因为要重新编译，会导致更新不方便，不方便替库的方式去调试，热更新等。
2. 并且可能还有符号问题，对用户来说，具备一定的集成负担。
3. 静态库的体积通常都很大，因为要等待链接符号筛选，所有的符号都保留在静态库里面，系统中静态库一旦变得多起来
对磁盘的存储要求也高了 

静态库优点
1. 代码安全性高，毕竟是链接到可执行程序里，用户不知道你的代码模块，业务发做替换。

动态库缺点
1. 安全性问题，只要接口不变，动态库是可以随意替换的，对于厂商来说不好监管
2. 代码保密性，动态库需要随可执行程序发布，竞争对手能够窥探模块一二 

动态库优点
1. 调试方便，可以支持随意替换，不用重新编译，热更新
2. 共享，系统多个应用可以共享一个动态库，减少磁盘存储压力

动态库缺点
1. 安全性问题，比如苹果就不支持第三方动态库  

总而言之就是：集成方便度、库体积、安全性  

####关于符号导出和符号隐藏 

可以认为整个编译和链接过程就是和符号做斗争。对于向外发布的应用，要做好符号隐藏，以防对方能够窥探自己的实现。
对每个平台有些差异，一般如下操作：

``` 
linux/android/ios/mac

#对于要导出的符号前面加上
__attribute__((visibility ("default")))

#然后编译指令加上, 加上之后，默认符号都是hidden，只有default才会导出.
-fvisibility=hidden -fvisibility-inlines-hidden

windows
#类名前加上 __declspec(dllexport)

#strip命令，也能够将不用的符号删除
strip xxx.so
``` 

####关于静态库动态库的操作工具（crash分析）

可以充分利用工具链里面的东西，能够查看符号，反解符号。除了工具链之外，操作系统平台也提供了一些工具，比如readelf等。

查看符号

比如linux平台提供了readelf命令去查看so的相关内容
``` 
# 会显示动态段的信息，其中有库的搜索路径 rpath
readelf -d xxx.so 
# 显示so库头部 
readelf -h xxx.so 
``` 
工具链中也有objdump来查看符号，也有一些比较好的破解工具，能够解析出静态库动态库符号
``` 
# 查看符号 
objdump -Tt xxx.so  
``` 
比如mac平台的Hopper Disassembler V4.   


反解符号

工具链中的add2line工具，能够通过堆栈地址，通过so库解析出符号。注意要用编译so库的工具链。
``` 
# 0029a068 为堆栈地址
./arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-addr2line 0029a068 -C -f -e /xxx/xxx/xxx.so
``` 

#### 说到工具，补充下性能测试工具吧

iOS平台有个非常方便的性能测试工具，集成到了xcode中，叫做instruments，通过app运行起来之后，可以跑个测试
查看下具体哪些函数的调用开销比较大。

当然我们也可以通过clock的方式去计数. 

by the way...
搞安全开发的人和编译优化的人，更加离不开符号吧。。。
搞优化的人，背后的思想还是离不开对计算机体系结构的思考，就是如何加速你的程序. （怎么充分利用好缓存和寄存器）

