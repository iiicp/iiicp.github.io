---
layout: post
title: c++中的网络编程
tags: c++/network
excerpt: about network programing
---  

### 前言  

此次总结代码请参考我的github仓库[Socket网络编程](https://github.com/iiicp/project-arrange/tree/master/SocketProgramming)

### socket编程 

典型的回声客户端实现，清晰明白了客户端和服务器的交互流程和核心API.

	服务端典型流程: socket() -> bind() -> listen() -> accept() -> (read()  write()) -> close();
	客户端典型流程: socket() -> connect() -> (read() write()) -> close()


常见socket编程问题 

0. tcp头部细节
	
	16位源端口 + 16位目的端口
	32位SEQ
	32位ACK
	窗口大小、校验和都是2个字节 + ...

	一共是20个字节的固定首部.

1. 端口范围2个字节，无符号数最大65535，其中0~1023为知名端口，用户端口最好在1024及以后
2. ip地址分类, 第一个字节以0开头为A类(0~127)，第一个字节以10开头(128~191)为B类，第一个字节以110开头(192-223)为C类.
	ipv4是4个字节，ipv6为16个字节.
3. 字节序，网络字节序都是大端序(高位字节在前(人类可读的方式))，IP地址和端口都要转成网络字节序来传输.htonl和htons函数.
	[关于字节序讲解比较清晰的文章](https://www.ruanyifeng.com/blog/2016/11/byte-order.html)  
4. 路由器和交换机的作用    
	路由器连接不同的局域网，是通过ip地址来进行转发
	交换机作用于特定局域网，是通过mac地址来进行转发
	路由器和交换机分别作用域网络层和数据链路层   
5. connect函数的调用时机是服务端调用listen函数之后，服务端调用listen函数之后会在accept函数处阻塞，等待用户调用connect.  
6. 服务器什么时候会创建连接请求队列？在调用listen函数的时候，内部会创建一个连接请求队列。accept会从连接请求中取出客户端请求进行处理。
7. 客户端为什么不需要调用bind函数？客户端调用connect函数时，操作系统会自动给套接字分配客户端本机ip地址和端口，其中端口是随机的
	服务端在请求队列中记录了这次连接请求，connect就会返回，或者出现异常connect会返回。
8.  tcp滑动窗口原理   
	套接字成功分配之后，每个套接字都会有两个缓冲区，分别是输入缓冲区(read)，和输出缓冲区(write). tcp协议有个滑动窗口会动态调节发送的数据
	量，本质上是通过套接字IO缓冲区的拥塞程度(是否快满了，是否空闲很多)来调整。tcp会保证发送到输出缓冲区的数据一定能够传输到对方。
9.  tcp三次握手
	第一次		A->B 	SYN(SEQ:1000, ACK:-)	   	
	第二次		B->A    SYN+ACK(SEQ:2000, ACK:1001)
	第三次		A->B  	ACK(SEQ:1001, ACK:2001)  

10. tcp正常传输数据 
	第一次		A->B 	SEQ:1200 数据100字节
	第二次		B->A    ACK:1301 已成功接收100个字节，请发送序列号为1301的数据包
	第三次		A->B 	SEQ:1301 数据200字节
	第四次		B->A 	ACK:1502 已成功接收200个字节，请发送序列号为1502的数据包 

	若没有收到ACK消息，则会触发超时重传机制.

11. tcp四次挥手 
	第一次	 	A->B 	FIN(SEQ:5000, ACK:-)
	第二次		B->A 	ACK(SEQ:7000, ACK:5001) B向A反馈，表示成功收到了请求断开的消息

	第三次 		B->A 	FIN(SEQ:7001, ACK:5001) 
	第四次		A->B 	ACK(SEQ:5001, ACK:7002) A向B反馈，表示成功收到了请求断开的消息

12. tcp怎样通过ack和seq保证消息不丢失? 	
	通过ACK的应答知道是否对方成功收到了自己发送的消息，如果没有收到应答，会重新发送SEQ消息

12. tcp的半关闭情况 
	因为tcp是双工的模式，可以支持半关闭。close函数是全关闭，半关闭通过shutdown函数来实现。
	半关闭会发送EOF消息。

13. tcp常用的socketopt参数   
	
	一: 通过getsockopt和setsockopt两个函数来查看和修改socket属性
	
	二: 通过SO_SENDBUF && SO_RCVBUF修改socket输入和输出缓冲区大小  

	通过设置SO_REUSEADDR为1，来解决bind() error. 场景是先进行ctrl+c关闭服务端，相当于服务端发送了FIN
	信息，此时再次用相同的端口来启动服务器，此时服务器会启动不了，出现bind() error错误。大约3分钟后，服务器
	可以启动起来。

	服务端 				
	ctrl+c -> FIN(SEQ:1111, ACK -)    	
	客户端
	ACK(SEQ: 2000, ACK: 1112)

	服务端(此时处于time_wait状态)
	谁先断开连接，谁就属于time_wait状态，属于time_wait状态时端口是占用状态

	客户端也会有time_wait状态，不过因为客户端每次连接都是动态分配端口号，所以客户端先断开连接，再次连接不会出现
	bind() error.

	time_wait状态的作用是保证最后的ACK消息可达. time_wait状态也并不是一直都好，有时候我们需要立即重启服务，所以
	需要将处于time_wait状态的端口号重新分配给新的套接字。

	三: TCP_NODELAY 
	Nagle算法是为了减少网络负载，每次发送一个包，需等待ACK后，才能再次发送下一个包，Nagle算法充分利用了缓冲区，因为在等待ACK
	的时候，缓冲区能够填入更多的数据，下一个包就能传输更多的数据了，使用Nagle算法能够大大减少网络包的数量，从而减少了网络负载。
	但是当网络数据包总量不变的情况下，关闭Nagle算法，速度会更快，因为不需要先等待ACK回来，比如传输大文件的时候。
	当传输大文件时，每次写入缓冲区的速度都很快，缓冲区都能填满，这个时候禁用Nagle算法，可以加快网络数据传输。因为缓冲区得到
	了最大化利用，每个包也都是必须的，不存在很多携带数据很少的包.

	当要关闭Nagle算法的时候，使用TCP_NODELAY选项，将其值修改为1.


### socket编程场景 

1. 场景
	本地机器两个进程间通信 
	远程两个进程间通信 
	进程间通信的其它方式
		管道和共享内存


2. 编程模型
	单进程、单线程的方式 (适用于客户端两个进程间通信场景)
	多线程模型 
	多进程模型
	io复用模型（select/poll/epoll）

### https协议

在socket的基础上封装了http的协议（特定的请求和响应），s表示的是ssl，在http建立连接的过程中，先用ssl来一层握手，
之后会用公钥来进行加密，http的传输内容.

### https编程 
1. 场景 
2. http的协议细节
3. ssl协议及其证书
4. curl的使用

### 网络编程实战分析 
	curl代码解析