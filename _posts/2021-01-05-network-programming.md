---
layout: post
title: c++中的网络编程
tags: c++/network
excerpt: about network programing
---  

### 前言  

此次总结代码请参考我的github仓库[Socket网络编程](https://github.com/iiicp/project-arrange/tree/master/SocketProgramming)

### socket编程 

典型的回声客户端实现，清晰明白了客户端和服务器的交互流程和核心API.

	服务端典型流程: socket() -> bind() -> listen() -> accept() -> (read()  write()) -> close();
	客户端典型流程: socket() -> connect() -> (read() write()) -> close()


常见socket编程问题 

0. tcp头部细节
	
	16位源端口 + 16位目的端口
	32位SEQ
	32位ACK
	窗口大小、校验和都是2个字节 + ...

	一共是20个字节的固定首部.

1. 端口范围2个字节，无符号数最大65535，其中0~1023为知名端口，用户端口最好在1024及以后
2. ip地址分类, 第一个字节以0开头为A类(0~127)，第一个字节以10开头(128~191)为B类，第一个字节以110开头(192-223)为C类.
	ipv4是4个字节，ipv6为16个字节.
3. 字节序，网络字节序都是大端序(高位字节在前(人类可读的方式))，IP地址和端口都要转成网络字节序来传输.htonl和htons函数.
	[关于字节序讲解比较清晰的文章](https://www.ruanyifeng.com/blog/2016/11/byte-order.html)  
4. 路由器和交换机的作用    
	路由器连接不同的局域网，是通过ip地址来进行转发
	交换机作用于特定局域网，是通过mac地址来进行转发
	路由器和交换机分别作用域网络层和数据链路层   
5. connect函数的调用时机是服务端调用listen函数之后，服务端调用listen函数之后会在accept函数处阻塞，等待用户调用connect.  
6. 服务器什么时候会创建连接请求队列？在调用listen函数的时候，内部会创建一个连接请求队列。accept会从连接请求中取出客户端请求进行处理。
7. 客户端为什么不需要调用bind函数？客户端调用connect函数时，操作系统会自动给套接字分配客户端本机ip地址和端口，其中端口是随机的
	服务端在请求队列中记录了这次连接请求，connect就会返回，或者出现异常connect会返回。
8.  tcp滑动窗口原理   
	套接字成功分配之后，每个套接字都会有两个缓冲区，分别是输入缓冲区(read)，和输出缓冲区(write). tcp协议有个滑动窗口会动态调节发送的数据
	量，本质上是通过套接字IO缓冲区的拥塞程度(是否快满了，是否空闲很多)来调整。tcp会保证发送到输出缓冲区的数据一定能够传输到对方。
9.  tcp三次握手

	第一次		A->B 	SYN(SEQ:1000, ACK:-)          
	第二次		B->A    SYN+ACK(SEQ:2000, ACK:1001)          
	第三次		A->B  	ACK(SEQ:1001, ACK:2001)       

10. tcp正常传输数据

	第一次		A->B 	SEQ:1200 数据100字节     
	第二次		B->A    ACK:1301 已成功接收100个字节，请发送序列号为1301的数据包      
	第三次		A->B 	SEQ:1301 数据200字节     
	第四次		B->A 	ACK:1502 已成功接收200个字节，请发送序列号为1502的数据包     

	若没有收到ACK消息，则会触发超时重传机制.

11. tcp四次挥手      

	第一次	 	A->B 	FIN(SEQ:5000, ACK:-)       
	第二次		B->A 	ACK(SEQ:7000, ACK:5001) B向A反馈，表示成功收到了请求断开的消息     

	第三次 		B->A 	FIN(SEQ:7001, ACK:5001)        
	第四次		A->B 	ACK(SEQ:5001, ACK:7002) A向B反馈，表示成功收到了请求断开的消息      

12. tcp怎样通过ack和seq保证消息不丢失?  

	通过ACK的应答知道是否对方成功收到了自己发送的消息，如果没有收到应答，会重新发送SEQ消息

12. tcp的半关闭情况 

	因为tcp是双工的模式，可以支持半关闭。close函数是全关闭，半关闭通过shutdown函数来实现。
	半关闭会发送EOF消息。

13. tcp常用的socketopt参数   
	
	一: 通过getsockopt和setsockopt两个函数来查看和修改socket属性
	
	二: 通过SO_SENDBUF && SO_RCVBUF修改socket输入和输出缓冲区大小  

	通过设置SO_REUSEADDR为1，来解决bind() error. 场景是先进行ctrl+c关闭服务端，相当于服务端发送了FIN
	信息，此时再次用相同的端口来启动服务器，此时服务器会启动不了，出现bind() error错误。大约3分钟后，服务器
	可以启动起来。

	服务端 				
	ctrl+c -> FIN(SEQ:1111, ACK -)    	
	客户端
	ACK(SEQ: 2000, ACK: 1112)

	服务端(此时处于time_wait状态)
	谁先断开连接，谁就属于time_wait状态，属于time_wait状态时端口是占用状态

	客户端也会有time_wait状态，不过因为客户端每次连接都是动态分配端口号，所以客户端先断开连接，再次连接不会出现
	bind() error.

	time_wait状态的作用是保证最后的ACK消息可达. time_wait状态也并不是一直都好，有时候我们需要立即重启服务，所以
	需要将处于time_wait状态的端口号重新分配给新的套接字。

	三: TCP_NODELAY 
	Nagle算法是为了减少网络负载，每次发送一个包，需等待ACK后，才能再次发送下一个包，Nagle算法充分利用了缓冲区，因为在等待ACK
	的时候，缓冲区能够填入更多的数据，下一个包就能传输更多的数据了，使用Nagle算法能够大大减少网络包的数量，从而减少了网络负载。
	但是当网络数据包总量不变的情况下，关闭Nagle算法，速度会更快，因为不需要先等待ACK回来，比如传输大文件的时候。
	当传输大文件时，每次写入缓冲区的速度都很快，缓冲区都能填满，这个时候禁用Nagle算法，可以加快网络数据传输。因为缓冲区得到
	了最大化利用，每个包也都是必须的，不存在很多携带数据很少的包.

	当要关闭Nagle算法的时候，使用TCP_NODELAY选项，将其值修改为1.


### socket编程场景 

场景 

本地机器两个进程间通信    
远程两个进程间通信   
进程间通信的其它方式比如管道和共享内存


编程模型

单进程、单线程的方式 (适用于客户端两个进程间通信场景)     
多线程模型     
多进程模型    
io复用模型（select/poll/epoll）    

### https协议

https = http + ssl   

ssl协商目的是将服务器公钥下发给客户端，客户端通过此公钥、服务器通过私钥，来用同一种加密算法结合ssl协商过程中的三个随机数来分别生成同样的秘钥，此秘钥是对称加密的秘钥，用于客户端和服务器后续传递消息加密。   
ssl协商共分为四步:   
1. 客户端向服务器请求证书公钥. 同时会传递客户端的ssl协议版本、支持的加密算法、压缩算法还有一个随机数1
2. 服务器向客户端发送协议版本、采用的加密算法、随机数2以及证书公钥。
3. 客户端校验证书公钥是否合法（通过证书颁发机构、根证书、证书的签名算法公共验证此证书是否伪造），如果合法，向服务器传输随机数3，以及编码改变通知、握手结束通知等消息。 
4. 服务器向客户端发送编码改变通知和握手结束通知。 

客户端通过证书公钥和协商的加密算法对三个随机数进行加密获得对称加密的私钥。   
服务器通过私钥和协商的加密算法对三个随机数进行加密获得对称加密的私钥。 
明显私钥内容是一样的，后续的http传递的信息都会通过此私钥进行加解密。    

http常见的返回状态码  

200表示ok
301/302表示重定向 
4xx客户端错误，比如404客户端请求的地址不存在 
5xx服务器错误，比如503

### https编程 

1. 场景    
用于短时交互场景，比如我们就是做个网络认证，不需要持续传输数据，通常数据格式采用json或者xml的方式。

2. curl的使用   
由于c++标准库目前还没有包含网络请求模块，目前比较采样的比较多的是curl，curl是c语言实现的，所以也是一个跨平台的方案。有时候我们也有必要采用原生的方案来做，因为curl配合openssl会导致动态库体积增大不少。 


### 网络编程实战案例 

1. 两个进程间通信(常用于间接实现目的，有可能当前进程没办法直接发起网络请求，需要借助另一个进程)  
2. sdk请求认证模块(需要保证多线程安全，资源有效退出)